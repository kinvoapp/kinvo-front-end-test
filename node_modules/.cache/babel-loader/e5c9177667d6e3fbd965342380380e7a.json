{"ast":null,"code":"const conversions = require('./conversions');\n\nconst route = require('./route');\n\nconst convert = {};\nconst models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n  const wrappedFn = function (...args) {\n    const arg0 = args[0];\n\n    if (arg0 === undefined || arg0 === null) {\n      return arg0;\n    }\n\n    if (arg0.length > 1) {\n      args = arg0;\n    }\n\n    return fn(args);\n  }; // Preserve .conversion property if there is one\n\n\n  if ('conversion' in fn) {\n    wrappedFn.conversion = fn.conversion;\n  }\n\n  return wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n  const wrappedFn = function (...args) {\n    const arg0 = args[0];\n\n    if (arg0 === undefined || arg0 === null) {\n      return arg0;\n    }\n\n    if (arg0.length > 1) {\n      args = arg0;\n    }\n\n    const result = fn(args); // We're assuming the result is an array here.\n    // see notice in conversions.js; don't use box types\n    // in conversion functions.\n\n    if (typeof result === 'object') {\n      for (let len = result.length, i = 0; i < len; i++) {\n        result[i] = Math.round(result[i]);\n      }\n    }\n\n    return result;\n  }; // Preserve .conversion property if there is one\n\n\n  if ('conversion' in fn) {\n    wrappedFn.conversion = fn.conversion;\n  }\n\n  return wrappedFn;\n}\n\nmodels.forEach(fromModel => {\n  convert[fromModel] = {};\n  Object.defineProperty(convert[fromModel], 'channels', {\n    value: conversions[fromModel].channels\n  });\n  Object.defineProperty(convert[fromModel], 'labels', {\n    value: conversions[fromModel].labels\n  });\n  const routes = route(fromModel);\n  const routeModels = Object.keys(routes);\n  routeModels.forEach(toModel => {\n    const fn = routes[toModel];\n    convert[fromModel][toModel] = wrapRounded(fn);\n    convert[fromModel][toModel].raw = wrapRaw(fn);\n  });\n});\nmodule.exports = convert;","map":{"version":3,"sources":["C:/Users/ingrisan/Documents/projeto/kinvo-front-end-test/projeto/node_modules/react-dev-utils/node_modules/color-convert/index.js"],"names":["conversions","require","route","convert","models","Object","keys","wrapRaw","fn","wrappedFn","args","arg0","undefined","length","conversion","wrapRounded","result","len","i","Math","round","forEach","fromModel","defineProperty","value","channels","labels","routes","routeModels","toModel","raw","module","exports"],"mappings":"AAAA,MAAMA,WAAW,GAAGC,OAAO,CAAC,eAAD,CAA3B;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAArB;;AAEA,MAAME,OAAO,GAAG,EAAhB;AAEA,MAAMC,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAYN,WAAZ,CAAf;;AAEA,SAASO,OAAT,CAAiBC,EAAjB,EAAqB;AACpB,QAAMC,SAAS,GAAG,UAAU,GAAGC,IAAb,EAAmB;AACpC,UAAMC,IAAI,GAAGD,IAAI,CAAC,CAAD,CAAjB;;AACA,QAAIC,IAAI,KAAKC,SAAT,IAAsBD,IAAI,KAAK,IAAnC,EAAyC;AACxC,aAAOA,IAAP;AACA;;AAED,QAAIA,IAAI,CAACE,MAAL,GAAc,CAAlB,EAAqB;AACpBH,MAAAA,IAAI,GAAGC,IAAP;AACA;;AAED,WAAOH,EAAE,CAACE,IAAD,CAAT;AACA,GAXD,CADoB,CAcpB;;;AACA,MAAI,gBAAgBF,EAApB,EAAwB;AACvBC,IAAAA,SAAS,CAACK,UAAV,GAAuBN,EAAE,CAACM,UAA1B;AACA;;AAED,SAAOL,SAAP;AACA;;AAED,SAASM,WAAT,CAAqBP,EAArB,EAAyB;AACxB,QAAMC,SAAS,GAAG,UAAU,GAAGC,IAAb,EAAmB;AACpC,UAAMC,IAAI,GAAGD,IAAI,CAAC,CAAD,CAAjB;;AAEA,QAAIC,IAAI,KAAKC,SAAT,IAAsBD,IAAI,KAAK,IAAnC,EAAyC;AACxC,aAAOA,IAAP;AACA;;AAED,QAAIA,IAAI,CAACE,MAAL,GAAc,CAAlB,EAAqB;AACpBH,MAAAA,IAAI,GAAGC,IAAP;AACA;;AAED,UAAMK,MAAM,GAAGR,EAAE,CAACE,IAAD,CAAjB,CAXoC,CAapC;AACA;AACA;;AACA,QAAI,OAAOM,MAAP,KAAkB,QAAtB,EAAgC;AAC/B,WAAK,IAAIC,GAAG,GAAGD,MAAM,CAACH,MAAjB,EAAyBK,CAAC,GAAG,CAAlC,EAAqCA,CAAC,GAAGD,GAAzC,EAA8CC,CAAC,EAA/C,EAAmD;AAClDF,QAAAA,MAAM,CAACE,CAAD,CAAN,GAAYC,IAAI,CAACC,KAAL,CAAWJ,MAAM,CAACE,CAAD,CAAjB,CAAZ;AACA;AACD;;AAED,WAAOF,MAAP;AACA,GAvBD,CADwB,CA0BxB;;;AACA,MAAI,gBAAgBR,EAApB,EAAwB;AACvBC,IAAAA,SAAS,CAACK,UAAV,GAAuBN,EAAE,CAACM,UAA1B;AACA;;AAED,SAAOL,SAAP;AACA;;AAEDL,MAAM,CAACiB,OAAP,CAAeC,SAAS,IAAI;AAC3BnB,EAAAA,OAAO,CAACmB,SAAD,CAAP,GAAqB,EAArB;AAEAjB,EAAAA,MAAM,CAACkB,cAAP,CAAsBpB,OAAO,CAACmB,SAAD,CAA7B,EAA0C,UAA1C,EAAsD;AAACE,IAAAA,KAAK,EAAExB,WAAW,CAACsB,SAAD,CAAX,CAAuBG;AAA/B,GAAtD;AACApB,EAAAA,MAAM,CAACkB,cAAP,CAAsBpB,OAAO,CAACmB,SAAD,CAA7B,EAA0C,QAA1C,EAAoD;AAACE,IAAAA,KAAK,EAAExB,WAAW,CAACsB,SAAD,CAAX,CAAuBI;AAA/B,GAApD;AAEA,QAAMC,MAAM,GAAGzB,KAAK,CAACoB,SAAD,CAApB;AACA,QAAMM,WAAW,GAAGvB,MAAM,CAACC,IAAP,CAAYqB,MAAZ,CAApB;AAEAC,EAAAA,WAAW,CAACP,OAAZ,CAAoBQ,OAAO,IAAI;AAC9B,UAAMrB,EAAE,GAAGmB,MAAM,CAACE,OAAD,CAAjB;AAEA1B,IAAAA,OAAO,CAACmB,SAAD,CAAP,CAAmBO,OAAnB,IAA8Bd,WAAW,CAACP,EAAD,CAAzC;AACAL,IAAAA,OAAO,CAACmB,SAAD,CAAP,CAAmBO,OAAnB,EAA4BC,GAA5B,GAAkCvB,OAAO,CAACC,EAAD,CAAzC;AACA,GALD;AAMA,CAfD;AAiBAuB,MAAM,CAACC,OAAP,GAAiB7B,OAAjB","sourcesContent":["const conversions = require('./conversions');\nconst route = require('./route');\n\nconst convert = {};\n\nconst models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\tconst result = fn(args);\n\n\t\t// We're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(fromModel => {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tconst routes = route(fromModel);\n\tconst routeModels = Object.keys(routes);\n\n\trouteModels.forEach(toModel => {\n\t\tconst fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n"]},"metadata":{},"sourceType":"script"}